//  worldmap.tjs
//  新增大地图

global.bigMap = new WorldMap(kag._primaryLayer, this);
global.openWorldMap = function ()
{	

	// 替代master文件的逻辑
	if(game.map.kind == "town") {
		game.party.visible = false;
		game.guest.visible = false;
		//exitTravelMode();
		game.clearWindows();
		global.bigMap.open();
	}
	else {game.exitTravelMode();
		game.clearWindows();
		game.autoMap.open(game.map);
        // System.inform(game.map.group.name);

        var btmLayer = game.autoMap.frameLayer;
        this.bigMapBtn = new DecoLayer(btmLayer); // 父图层为 frameLayer
        with (this.bigMapBtn) 
        {
            .loadImages("mapicon");
            .setPos(20, 60); // 按钮位置（根据界面调整，示例为右上角）
            .setSize(80, 70);  // 按钮尺寸（与图片尺寸匹配）
            .absolute = 3000;  // 层级（高于 frameLayer 其他元素，确保可见）
            .hitThreshold = 60; // 点击判定范围（扩大点击区域，避免点不到）
            .visible = true;   // 显示按钮
            .selectable = true;
	    }

        bigMapBtn.onMouseEnter = function () {
            // 可选：添加悬停效果（如缩放/高亮）
            this.scaleX = 1.1;
            this.scaleY = 1.1;
            playSound("point", 2); // 可选：播放悬停音效
        };
        bigMapBtn.onMouseLeave = function () {
            // 恢复正常状态
            this.scaleX = 1;
            this.scaleY = 1;
        };
        bigMapBtn.onMouseUp = function (x, y, button) {
            if (button == mbLeft) { // 左键点击
                global.bigMap.open(); // 打开大地图
            }
        };

        // 存储按钮引用，避免重复创建
        game.autoMap.bigMapBtn = bigMapBtn;
    }

};


//个人改动----------------------------------------------------------------------------------------
class WorldMap extends Layer
{
    // 全屏可拖拽图片图层（含Open/Close功能）
    var master;               // 管理对象引用
    var imageLayer;           // 图片渲染图层
    var dragState = false;    // 拖拽状态标记
    // 拖拽坐标记录
    var startX, startY;
    var originLeft, originTop;
    var imgWidth, imgHeight;  // 图片原始尺寸
    var viewWidth, viewHeight;// 视图窗口尺寸
    var isOpened = false;     // 页面打开状态标记

	// +++++++++ 新增：据点图标相关变量 +++++++++
    var iconLayer;      // 据点图标正常图层
    var lightingLayer; // 据点图标高亮图层
    var iconWidth, iconHeight; // 据点图标尺寸
    var isHoverIcon = false; // 是否悬停在据点图标上
    var iconList = [];        // 存储所有图标图层实例
	// var lightingList = []; 	//存储每个图标的专属高亮图层
	var currentHighlightedIcon = null;  // 记录当前高亮的图标，避免重复播放音效
	var nameDisplayLayer;  // 右上角文本展示图层
	var currentDisplayName = null;  // 记录当前显示的名称（用于去重）
    var transTag = true;   //  汉化标识，默认有汉化
    
    var townPlayerSymbol;   //  动画小人图标
    var playerTimer;

    function WorldMap(par, master)
    {
        super.Layer(par.window, par);
        this.master = master;
        this.name = "worldmap";

        // 初始化视图尺寸（全屏）
        this.viewWidth = kag.scWidth;
        this.viewHeight = kag.scWidth;
        this.setSize(this.viewWidth, this.viewHeight);
        this.visible = false;  // 默认隐藏
        
        // 创建图片渲染图层
        this.imageLayer = new DecoLayer(this);
        with(this.imageLayer)
        {
            .absolute = 2004;  // 层级高于背景
            .visible = false;  // 初始隐藏，open时显示
        }

		// icon图层
		this.iconContainer = new DecoLayer(this.imageLayer);
		with(this.iconContainer)
		{
            .absolute = 2006;  // 层级高于地图
			// .viewWidth = this.parent.window.width;
			// .viewHeight = this.parent.window.height;
            // .setSize(this.viewWidth, this.viewHeight);
			.setSize(2400, 2000);
            .visible = false;  // 初始隐藏，open时显示
        }
		// this.iconContainer.setSize(this.viewWidth, this.viewHeight);

		this.lightingLayer = new LightingLayer(this.iconContainer);  // 父容器为iconContainer，与图标同层级
		with(this.lightingLayer)
		{
			.absolute = 2009;  // 层级高于图标（图标是2008），确保不被遮挡
			.visible = false;  // 初始隐藏
		}
		lightingLayer.paintAll(this);

		this.nameDisplayLayer = new DecoLayer(this);
		with(this.nameDisplayLayer)
		{
			.absolute = 2010;  // 层级最高
			.visible = false;  // 初始隐藏
			// 加载背景图片（frame_door_plate，340x40）
			.loadImages("frame_door_plate");
			// 计算右上角位置：距离右边缘20px，上边缘20px（背景图左上角坐标）
			// 背景图宽度340 → left = 1024 - 340 - 20 = 664（右边缘留20px间距）
			.setPos(660, 20);  // left=664, top=20
			.setSize(340, 40);  // 背景图尺寸固定为340x40
			// 文本居中显示在背景图上（根据引擎支持的文本对齐属性调整）
			.textAlign = "center";  // 水平居中
			.verticalAlign = "middle";  // 垂直居中
			.textColor = "#FFFFFF";  // 文本颜色（示例：白色，可根据背景图调整）
			.fontSize = 14;  // 字体大小（根据背景图尺寸调整）
		}


        // 事件监听设置
        this.focusable = true;
        this.hitThreshold = 0;
    }

    /**
     * 打开全屏图片页面
     * @param {String} imgPath 可选，图片路径（默认使用初始化时的路径）
     */
    function open()
    {
        if (this.isOpened) return;  // 避免重复打开
        
        // 加载图片资源
        this.loadImageResource("mapworld2");
        
        // 更新视图尺寸（适配当前窗口）
        this.viewWidth = 1024;
        this.viewHeight = 768;
        this.setSize(this.viewWidth, this.viewHeight);
        
        // 初始居中显示
        this.originLeft = (this.viewWidth - this.imgWidth) / 2;
        this.originTop = (this.viewHeight - this.imgHeight) / 2;
        this.imageLayer.setPos(this.originLeft, this.originTop);

        // 小人图标
        townPlayerSymbol = game.townView.playerSymbol;
        this.savedPlayerParent = townPlayerSymbol.parent; // 记录原父图层
        this.savedPlayerVisible = townPlayerSymbol.visible; // 记录原可见性
        townPlayerSymbol.parent = this.imageLayer;
        townPlayerSymbol.visible = true;  // 确保图标可见

        

        //  判断是否日文原版，有transVersion字段视为中文，如有其他语言翻译需求，建议直接修改worldlist里的地点名称
        if (typeof global.kag.transVersion == "undefined") this.transTag = false;

		// 加载CSV并创建图标
        this.loadIconFromCSV("worldlist.csv");


        this.summarizeOpenedBlocks(game.mapData);

        // 显示页面
        this.visible = true;
        this.imageLayer.visible = true;
		this.iconContainer.visible = true;
        this.isOpened = true;
        
        // 只打印name字段，避免任何循环和复杂判断
        // var firstMap = game.mapData[0];
        // System.inform("[0].name: " + firstMap.name + 
        // "\n[0].displayName: " + firstMap.displayName +
        // "\n[0].group[0].name: " + firstMap.group[0].name +
        // "\n[0].group[1].name: " + firstMap.group[1].name +
        // "\n[0].group[2].name: " + firstMap.group[2].name +
        // "\n[0].group[2].visited: " + firstMap.group[2].visited +
        // "\n[0].kind: " + firstMap.kind +
        // "\ngame.map.name: " + game.map.name +
        // "\ngame.map.group.name: " + game.map.group.name +
        // "\ngame.map.displayName: " + game.map.displayName

        // 聚焦以接收键盘事件
        this.focus();
        
		
        // 播放打开音效（可选）
        // if (this.master && this.master.playSound)
        //     this.master.playSound("open_image");
    }
    

    /**
     * 关闭全屏图片页面
     */
    function close()
    {
        if (!this.isOpened) return;  // 避免重复关闭
        
        // 隐藏页面元素
        this.imageLayer.visible = false;
		this.iconContainer.visible = false;
        townPlayerSymbol = game.townView.playerSymbol;
        townPlayerSymbol.parent = this.savedPlayerParent; // 恢复原父图层
        townPlayerSymbol.visible = this.savedPlayerVisible; // 恢复原可见性

        // 【新增】停止动画定时器，避免内存泄漏
        if (this.playerTimer) {
            this.playerTimer.enabled = false;
        }

        this.visible = false;
        this.isOpened = false;
		game.party.visible = true;
        game.guest.visible = true;
        
        // 释放焦点
        // this.blur();
        
        // 播放关闭音效（可选）
        // if (this.master && this.master.playSound)
        //     this.master.playSound("close_image");
        
        // 触发关闭回调（可选）
        // if (this.onClose) this.onClose();
    }

    function loadImageResource(source)
    {
        // 加载图片资源并获取尺寸
		this.imageLayer.loadImages(source);
        this.imgWidth = this.imageLayer.imageWidth;
        this.imgHeight = this.imageLayer.imageHeight;
    }

    function loadIconResource(source)
    {
        // 加载正常状态图标
        this.iconContainer.loadImages(source);
        
        // 获取图标尺寸（默认正常和高亮图标尺寸一致）
        this.iconWidth = this.iconContainer.imageWidth;
  		this.iconHeight = this.iconContainer.imageHeight;
    }

    //  个人心得（就写在这里吧）：最初就是欣赏游戏的风格，让我回想起当年MM6年代的游戏感觉，又觉得作者老登一个人搞这些确实不容易，
    //  于是心血来潮想搞个地图mod，好增加一些引导和代入感。由于本人没有程序员的经历，mod的代码基本都是由Ai写的，
    //  不得不承认时代进步了，Ai真的很强大。图片素材也都是前作的，刚好风格也统一，可惜我美术造诣等于0。
    //  现在想想做成这样确实不容易。后续应该会逐步优化迭代，还有很多卡点没解决，之后再增加任务指引之类的功能。
    //  To 其他作者：考虑到作者一直在更新，所以mod整体绕过了master文件，以避免频繁的修复更新，只略微改动了component文件。
    //  留个邮箱吧：geilians@163.com

	// +++++++++ 新增：从CSV加载图标 +++++++++
    function loadIconFromCSV(csvPath)
    {
        // 读取CSV文件并解析
        var csvData = csvToArray(csvPath, false, true);
		// System.inform("CSV解析行数: " + csvData.count); 
		var flipH = false;
		var flipV = false;
        if (!csvData || csvData.count === 0) return;

        // 遍历CSV数据创建图标
        for (var i = 0; i < csvData.count; i++)   // 从1开始跳过表头
		{
            var row = csvData[i];
            var iconImgLayer = new DecoLayer(this.iconContainer);
            
            // 设置图标属性
            with(iconImgLayer)
            {
                .loadImages(row.iconPic);  // 加载图标图片
                .setPos(row.posX, row.posY);  // 设置位置
				// setPos(this.viewWidth / 2, this.viewHeight / 2);
                .absolute = 2008;  // 确保图标显示在地图上方
				.visible = false;
            }

            //  用来判断村庄是否显示，目前采用地图探索位置来判断，width从0开始算，要多加1
            if (row.name == "ブレイブタウン") iconImgLayer.visible = true;  //  勇者村
            if (row.name == "シーガルの村") //  海鸥村
            {   
                if (o.コリンズの森.record[78+40*2]) iconImgLayer.visible = true;
            }
            if (row.name == "サファイアシティ") //  蓝宝石城
            {   
                if (o.ランドン渓谷・崖上.record[78+31*24]) iconImgLayer.visible = true;
            }
            if (row.name == "ノースロップ村") //  霜陲村
            {   
                if (o.フーラ雪原・南の森.record[38+22*3]) iconImgLayer.visible = true;
            }
            if (row.name == "地下の町ライムストーン") //  地下町
            {   
                if (o.大洞窟Ｂ５.record[4+9*5]) iconImgLayer.visible = true;
            }
            if (row.name == "ダストウェルの町") //  尘落镇
            {   
                if (o.タルハ砂漠・南.record[1+18*1]) iconImgLayer.visible = true;
            }

            // 【新增1：初始化blocks属性（默认0），关联CSV的oneofMap用于后续统计】
            iconImgLayer.blocks = 0;  // 初始值0，后续会被summarizeOpenedBlocks覆盖
            iconImgLayer.allBlocks = 0;
            iconImgLayer.oneofMap = row.oneofMap;  // 关联地图组数据的key
            iconImgLayer.displayName = row.displayName;  // 绑定显示名称
            iconImgLayer.name = row.name;

            if (this.transTag == false) iconImgLayer.displayName = row.name;    //  没有中文汉化时显示日文名称

            //  小人图标
            if (game.map.kind == "town") 
            {
                if (row.name == game.map.name)
                {
                    townPlayerSymbol.setPos(row.posX + 40, row.posY);
                    townPlayerSymbol.visible = true;
                }
            }
            else if (row.displayName == game.map.group.name || row.name == game.map.group.name)
            {
                this.playerTimer = new Timer(this.playerWalking, "");
                this.playerTimer.interval = 300;
                // townPlayerSymbol.absolute = 2010;
                this.playerTimer.enabled = true;
                townPlayerSymbol.setPos(row.posX + 30, row.posY);
                townPlayerSymbol.visible = true;
            }
            
			// 设置翻转（h:水平翻转, v:垂直翻转）翻转功能还未做
			// if (row.isFlip === "h") flipH = true;
			// if (row.isFlip === "v") flipV = true;
            
            // 存储图标实例用于后续管理
            this.iconList.push(iconImgLayer);
			// System.inform("当前lightingList长度: " + this.lightingList.length); // 应随循环递增
        }
    }

    function onMouseDown(x, y, button, shift)
    {
        // 左键按下时开始拖拽（仅图片区域内有效）
        if(button == mbLeft && this.isPointInImage(x, y))
        {
            this.dragState = true;
            // 记录初始坐标
            this.startX = x;
            this.startY = y;
            this.originLeft = this.imageLayer.left;
            this.originTop = this.imageLayer.top;
            // this.setCursor("grabbing");  // 鼠标样式切换为"抓取"
        }
        // 右键点击背景关闭页面
        else if(button == mbRight)
        {
            this.close();
        }
        super.onMouseDown(...);
    }

    function onMouseMove(x, y, shift)
    {
        // 拖拽中更新位置
        if(this.dragState)
        {
            // 计算位移差值
            var deltaX = x - this.startX;
            var deltaY = y - this.startY;
            // ========== 新增：拖拽边界限制计算 ==========
            // 目标位置 = 初始位置 + 位移差值
            var targetLeft = this.originLeft + deltaX;
            var targetTop = this.originTop + deltaY;
            
            // 边界限制逻辑：
            // 1. 左边界：地图左边缘不能超过窗口左边缘（0）
            // 2. 右边界：地图右边缘不能超过窗口右边缘（viewWidth）→ 等价于 left ≥ viewWidth - imgWidth
            // 3. 上边界：地图上边缘不能超过窗口上边缘（0）
            // 4. 下边界：地图下边缘不能超过窗口下边缘（viewHeight）→ 等价于 top ≥ viewHeight - imgHeight
            var maxLeft = 0;  // 左边界最大值（不能再往右拖）
            var minLeft = this.viewWidth - this.imgWidth;  // 左边界最小值（不能再往左拖）
            var maxTop = 0;  // 上边界最大值（不能再往下拖）
            var minTop = this.viewHeight - this.imgHeight;  // 上边界最小值（不能再往上拖）
            
            // 限制最终位置在边界内
            targetLeft = Math.max(minLeft, Math.min(maxLeft, targetLeft));
            targetTop = Math.max(minTop, Math.min(maxTop, targetTop));
            // ========== 边界限制计算结束 ==========
            
            // 更新图片位置（使用限制后的坐标）
            this.imageLayer.setPos(targetLeft, targetTop);
        }
		// +++++++++ 新增：据点图标高亮逻辑 +++++++++
        else if (this.isOpened)
        {
            // 转换鼠标坐标为地图相对坐标（因图标随地图移动，需计算相对于imageLayer的位置）
            var mapRelativeX = x - this.imageLayer.left;
            var mapRelativeY = y - this.imageLayer.top;
			var isHoverAny = false;
			var hoveredIcon = null;  // 记录当前悬停的图标
            
            // 检查是否悬停在任何图标上（修复：用for循环替代forEach）
            for (var i = 0; i < this.iconList.length; i++) {
                var icon = this.iconList[i];
                if (icon.blocks <= 0 && !icon.visible) continue;
                var iconLeft = icon.left;
                var iconTop = icon.top;
                var iconWidth = icon.imageWidth;
                var iconHeight = icon.imageHeight;

                if (mapRelativeX >= iconLeft && mapRelativeX <= iconLeft + iconWidth &&
                    mapRelativeY >= iconTop && mapRelativeY <= iconTop + iconHeight) {
                    hoveredIcon = icon;  // 记录当前悬停的图标
                	isHoverAny = true;
					// 跳出循环（如果只需要高亮第一个命中的图标）
					break;
                }
            }

            // 处理高亮和音效
        	if (isHoverAny) {
				// 若当前悬停的图标是新图标，播放音效
				if (hoveredIcon !== this.currentHighlightedIcon) {
					playSound("point", 2);
					this.currentHighlightedIcon = hoveredIcon;  // 更新记录
				}

				// +++++++++ 新增：更新右上角文本图层 +++++++++
				// 仅当名称变化时更新，避免重复刷新
				if (hoveredIcon.displayName !== this.currentDisplayName) {
					this.nameDisplayLayer.clear();
					this.nameDisplayLayer.drawText(20, 5, hoveredIcon.displayName, 0xFFFFFF, , , 2048, 0x000000, 1.2);  // 设置文本内容
                    if (hoveredIcon.blocks > 0) {
                        var rate = "%.1f".sprintf(hoveredIcon.blocks / hoveredIcon.allBlocks * 100);
                        this.nameDisplayLayer.drawText(240, 5, rate + "％", rate >= 100 ? 0xF080E0 : 0xE4F8FF);
					}
                    this.currentDisplayName = hoveredIcon.displayName;  // 记录当前名称
				}
				this.nameDisplayLayer.visible = true;  // 显示文本图层
                // System.inform(game.mapData[1].group[0].openedBlocks + "，" + game.mapData[1].group[1].openedBlocks + "，" + game.mapData[1].group[2].name);
                // System.inform(game.map.group.name);
                // System.inform(game.mapData[4].name +","+ game.mapData[5].name +","+ game.mapData[6].name +","+ game.mapData[7].name);

                // game.map = o.町外れの遺跡Ｂ１;
                // game.map.group.name = o.郊区遗迹;
                // var idx = game.autoMap.levelBoard.openMaps.find("町外れの遺跡Ｂ１");
                // game.openAutoMap();
                // game.autoMap.open([idx]);
                // game.autoMap.open(o.町外れの遺跡Ｂ１);

                // game.autoMap.scaleLayer.visible = true;
                // game.autoMap.scaleLayer.absolute = 2100;
                // imageLayer.visible = false;



				// 显示高亮
				this.lightingLayer.setPos(hoveredIcon.left, hoveredIcon.top);
				this.lightingLayer.setSize(hoveredIcon.imageWidth, hoveredIcon.imageHeight);
				this.lightingLayer.visible = true;
			} else {
				// 未悬停时重置
				this.currentHighlightedIcon = null;
				this.lightingLayer.visible = false;

				// +++++++++ 新增：隐藏文本图层 +++++++++
				this.nameDisplayLayer.clear();
				this.nameDisplayLayer.visible = false;
				this.currentDisplayName = null;  // 重置当前名称
			}
        	this.isHoverIcon = isHoverAny;
        }
        super.onMouseMove(...);
    }

    function onMouseUp(x, y, button, shift)
    {
        // 结束拖拽状态
        if(button == mbLeft && this.dragState)
        {
            this.dragState = false;
            // this.setCursor("default");  // 恢复鼠标样式
        }
        super.onMouseUp(...);
    }

    function onMouseLeave()
    {
        // 离开图层时强制结束拖拽
        if(this.dragState)
        {
            this.dragState = false;
            // this.setCursor("default");
        }
        // +++++++++ 修改：离开图层时隐藏高亮 +++++++++
        this.lightingLayer.visible = false;
        this.isHoverIcon = false;		

        super.onMouseLeave();
    }

    function onKeyDown(key, shift)
    {
        // 支持ESC键关闭全屏
        if(key == BT_CANCEL)
        {
            this.close();
        }
        // 支持Enter键关闭（可选）
        // else if(key == BT_OK)
        // {
        //     this.close();
        // }
        // super.onKeyDown(...);
    }

    // +++++++++ 在iconList中添加blocks属性存储汇总数量 +++++++++
    function summarizeOpenedBlocks(mapData) {
        
        // 遍历所有图标数据，直接在iconList中添加blocks属性
        for (var i = 0; i < this.iconList.length; i++) {
            var icon = this.iconList[i];
            // 为每个图标初始化blocks属性（默认为0）
            icon.blocks = 0;
            icon.allBlocks = 0;
            var oneofMapValue = icon.oneofMap;
            var displayName = icon.displayName;
            if (oneofMapValue == "") continue;
            // 查找匹配的mapData项
            var targetMapData = null;
            for (var j = 0; j < mapData.length; j++) {
                if (mapData[j].name == oneofMapValue) {
                    targetMapData = mapData[j];
                    break;
                }
            }
            
            if (!targetMapData || !targetMapData.group) continue;
            
            // 计算当前图标关联的openedBlocks总和
            var blocksSum = 0;
            var allBlocksSum = 0;
            for (var k = 0; k < targetMapData.group.length; k++) {
                var group = targetMapData.group[k];
                if (group.openedBlocks) {
                    var blockValue = group.openedBlocks;
                    var allBlockValue = group.allBlocks;
                    blocksSum += blockValue;
                    allBlocksSum += allBlockValue;
                }
            }
            
            // 直接在图标对象上添加blocks属性存储总和
            icon.blocks = blocksSum;
            icon.allBlocks = allBlocksSum;
            icon.visible = (icon.blocks > 0 || icon.oneofMap == "town");
        }
        return this.iconList; // 返回带blocks属性的图标列表
    }

	function csvToArray(file, tab, inHead, inIndex, blankLine)
	{
		// 取り込むＣＳＶファイルにはＫＡＧっぽくコメントを書けるようにしてある
		// tab が true だとタブ区切り
		// inHead が true だと一番上の段を名前（見出し）にして辞書配列を作成する
		// inIndex が true だと一番左の列がインデックス扱いになる
		// blankLine を true にすると空行も数えて空文字列として配列に入れる

		var line = [];
		var store = [];
		var temp = [];
		var dicNames = [];
		var index = -1;
		var regSemi = /^\t*\;/;
		var regQuote = /^\".*\"$/;
		var regNotNumber = /[^0-9\-\+\.]/;

		// ファイル読み込み
		line.load(file);

		// 編集＆保存
		for(var i = 0; i < line.count; i++)
		{
			if(regSemi.test(line[i]) || (line[i] == '' && ! blankLine)) continue;

			// 切り出し
			if(tab) temp.split(/\t/, line[i], , false);		// タブ区切り
			else    temp.split("," , line[i], , false);		// カンマ区切り

			// 出力された要素（文字列）を適当な型に変えてみる作業
			for(var j = 0; j < temp.count; j++)
			{
				if(! regQuote.test(temp[j]))
				{
					// クォーテーションがなくても明らかに数値じゃないっぽいのは文字列のままにしておく
					// （たまにそういうＣＳＶを吐くソフトがあるため……中国製のエクセルもどきとか）
					if(! regNotNumber.test(temp[j]) || temp[j] == "true" || temp[j] == "false")
						temp[j] = + temp[j];
					else if(temp[j] == "")
						temp[j] = void;
				}
				else
				{
					temp[j] = temp[j].replace(/^\"/, "");
					temp[j] = temp[j].replace(/\"$/, "");
				}
			}

			// 見出しが指定されている場合見出しを作成する
			// 今さら気付いたけど count の代わりに length を使ってもいいっぽい マニュアルには書いてないけど
			if(inHead && dicNames.length == 0)
			{
				dicNames.assign(temp);
				if(inIndex) dicNames.erase(0);
				continue;
			}

			// 出力データのインデックスを決定
			if(inIndex)
			{
				if(temp[0] === void)
				{
					System.inform("最初の列にインデックスがありません      \n\" "
						+ file + " \"    " + (i + 1) + " 行目", "CSVファイル読み込みエラー");
					continue;
				}
				index = temp[0];	// inIndex が true のときは最初の要素をインデックスに変換
				temp.erase(0);
			}
			else
			{
				index ++ ;	// inIndex が false のときは１つ足すだけ
			}

			// 変換した物を新しい配列に入れる
			if(inHead)
			{
				// dicNames で指定された名前で辞書配列に入れる
				store[index] = %[];
				for(var j = 0; j < dicNames.count; j++)
				{
					store[index][dicNames[j]] = temp[j];
				}
			}
			else
			{
				// 普通にコピーするだけ
				store[index] = [];
				store[index].assign(temp);
			}
		}

		return store;
	}

    function playerWalking()
	{
		if(! enabled) return;
		townPlayerSymbol.imageLeft = -80 - townPlayerSymbol.imageLeft;
	}

    /**
     * 检查坐标是否在图片区域内
     * @param {Number} x 鼠标X坐标
     * @param {Number} y 鼠标Y坐标
     * @returns {Boolean} 是否在图片区域内
     */
    function isPointInImage(x, y)
    {
        var imgLeft = this.imageLayer.left;
        var imgTop = this.imageLayer.top;
        return x >= imgLeft && x <= imgLeft + this.imgWidth 
            && y >= imgTop && y <= imgTop + this.imgHeight;
    }

	// +++++++++ 新增：检查坐标是否在据点图标区域内 +++++++++
    function isPointInIcon(x, y)
    {
        var iconLeft = this.iconLayer.left;
        var iconTop = this.iconLayer.top;
        return x >= iconLeft && x <= iconLeft + this.iconWidth
            && y >= iconTop && y <= iconTop + this.iconHeight;
    }

    /**
     * 设置关闭回调函数
     * @param {Function} callback 关闭时触发的函数
     */
    function setOnClose(callback)
    {
        this.onClose = callback;
    }

    function finalize()
    {
        // 资源清理
        invalidate this.imageLayer;
		invalidate this.iconContainer;
		invalidate this.lightingLayer;
		invalidate this.nameDisplayLayer;
        super.finalize();
    }

}
